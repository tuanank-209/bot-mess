module.exports.config = {
    name: "setname",
    version: "2.0.0",
    hasPermssion: 0,
    credits: "Tr√∫cCute mod by Niio-team (Cthinh || Vtuan)",
    description: "ƒê·ªïi bi·ªát danh trong nh√≥m c·ªßa b·∫°n ho·∫∑c c·ªßa ng∆∞·ªùi b·∫°n tag",
    commandCategory: "Nh√≥m",
    usages: "tr·ªëng/tag/check/all/del/call + name",
    cooldowns: 5
}
const fs = require('fs-extra');

const setn = "./modules/data/setname.json";
if (!fs.existsSync(setn)) {
    fs.writeFileSync(setn, JSON.stringify([]));
}
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

module.exports.run = async ({ api, event, args, Users, Threads }) => {
    let { threadID, messageReply, senderID, mentions, type, participantIDs } = event;
    let read = await fs.readFile(setn, 'utf-8');
    let Data = read ? JSON.parse(read) : [];
    let threadEntry = Data.find(entry => entry.threadID === event.threadID);
    switch (args[0]) {
        case 'call':
        case 'Call': {
            const dataThread = (await Threads.getData(threadID)).threadInfo;
            if (!dataThread.adminIDs.some(item => item.id === senderID)) return api.sendMessage('‚ö†Ô∏è B·∫°n kh√¥ng ƒë·ªß quy·ªÅn h·∫°n', threadID);
            const dataNickName = (await Threads.getData(threadID)).threadInfo.nicknames;
            const objKeys = Object.keys(dataNickName);
            const notFoundIds = participantIDs.filter(id => !objKeys.includes(id));
            const mentions = [];

            let tag = '';
            for (let i = 0; i < notFoundIds.length; i++) {
                const id = notFoundIds[i];
                const name = await Users.getNameUser(id);
                mentions.push({ tag: name, id });

                tag += `${i + 1}. @${name}\n`;
            }

            const bd = 'üì£ Vui l√≤ng setname ƒë·ªÉ m·ªçi ng∆∞·ªùi nh·∫≠n bi·∫øt b·∫°n d·ªÖ d√†ng h∆°n';

            const message = {
                body: `${bd}\n\n${tag}`,
                mentions: mentions
            };
            api.sendMessage(message, threadID);
            return;
        }

        case 'del':
        case 'Del': {
            const threadInfo = (await Threads.getData(threadID)).threadInfo;
            if (!threadInfo.adminIDs.some(admin => admin.id === senderID)) {
                return api.sendMessage(`‚ö†Ô∏è Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng`, threadID);
            }
            const dataNickName = threadInfo.nicknames
            var dataNotNN = []
            const objKeys = Object.keys(dataNickName);
            const notFoundIds = participantIDs.filter(id => !objKeys.includes(id));
            await notFoundIds.map(async (id) => {
                try {
                    api.removeUserFromGroup(id, threadID)
                } catch (e) {
                    console.log(e)
                }
            });
            return api.sendMessage(`‚úÖ ƒê√£ x√≥a th√†nh c√¥ng nh·ªØng th√†nh vi√™n kh√¥ng setname`, threadID)
        }
        case 'check':
        case 'Check': {
            const dataNickName = (await Threads.getData(threadID)).threadInfo.nicknames
            var dataNotNN = []
            const objKeys = Object.keys(dataNickName);
            const notFoundIds = participantIDs.filter(id => !objKeys.includes(id));
            var msg = 'üìù Danh s√°ch c√°c ng∆∞·ªùi d√πng ch∆∞a setname\n',
                num = 1;
            await notFoundIds.map(async (id) => {
                const name = await Users.getNameUser(id)
                msg += `\n${num++}. ${name}`
            });
            msg += `\n\nüìå Th·∫£ c·∫£m x√∫c v√†o tin nh·∫Øn n√†y ƒë·ªÉ kick nh·ªØng ng∆∞·ªùi kh√¥ng setname ra kh·ªèi nh√≥m`
            return api.sendMessage(msg, threadID, (error, info) => {
                global.client.handleReaction.push({
                    name: this.config.name,
                    messageID: info.messageID,
                    author: event.senderID,
                    abc: notFoundIds
                })
            })
        }
            break;
        case 'help':
            return api.sendMessage(
                `1. "setname + name" -> ƒê·ªïi bi·ªát danh c·ªßa b·∫°n\n` +
                `2. "setname @tag + name" -> ƒê·ªïi bi·ªát danh c·ªßa ng∆∞·ªùi d√πng ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p\n` +
                `3. "setname all + name" -> ƒê·ªïi bi·ªát danh c·ªßa t·∫•t c·∫£ th√†nh vi√™n\n` +
                `4. "setname check" -> Hi·ªÉn th·ªã danh s√°ch ng∆∞·ªùi d√πng ch∆∞a ƒë·∫∑t bi·ªát danh\n` +
                `5. "setname del" -> X√≥a ng∆∞·ªùi d√πng ch∆∞a setname (ch·ªâ d√†nh cho qu·∫£n tr·ªã vi√™n)\n` +
                `6. "setname add + k√≠ t·ª±" -> th√™m k√≠ hi·ªáu c·ªßa box khi setname (ch·ªâ d√†nh cho qu·∫£n tr·ªã vi√™n)\n` +
                `7. "setname rm" -> x√≥a k√≠ t·ª± c·ªßa box (ch·ªâ d√†nh cho qu·∫£n tr·ªã vi√™n)\n` +
                `8. "setname call" -> Y√™u c·∫ßu ng∆∞·ªùi d√πng ch∆∞a ƒë·∫∑t bi·ªát danh ƒë·∫∑t bi·ªát danh`, threadID);

        case 'all':
        case 'All': {

            try {
                const name = (event.body).split('all')[1]
                var num = 1;
                for (const i of participantIDs) {
                    num++
                    try {
                        api.changeNickname(name, threadID, i)
                    } catch (e) {
                        console.log(num + " " + e)
                    }
                    delay(2500)

                }
                return api.sendMessage(`‚úÖ ƒê√£ ƒë·ªïi bi·ªát danh th√†nh c√¥ng cho t·∫•t c·∫£ th√†nh vi√™n`, threadID)
            } catch (e) {
                return console.log(e, threadID)
            }
        }

        case 'add':
        case 'Add': {
            const content = (args.slice(1, args.length)).join(" ");
            if (threadEntry) {
                threadEntry.nameUser = content;
            } else {
                const data = {
                    threadID: event.threadID,
                    nameUser: content
                };
                Data.push(data);
            }
            await fs.writeFile(setn, JSON.stringify(Data, null, 4), 'utf-8');
            return api.sendMessage("üåü ƒê√£ th√™m k√≠ hi·ªáu th√†nh c√¥ng!\nK√≠ hi·ªáu: " + content, event.threadID, event.messageID);
        }

        case 'rm':
        case 'Rm': {
            if (threadEntry) {
                Data = Data.filter(entry => entry.threadID !== event.threadID);
                await fs.writeFile(setn, JSON.stringify(Data, null, 4), 'utf-8');
                return api.sendMessage("‚úÖ ƒê√£ x√≥a k√≠ hi·ªáu nh√≥m!", event.threadID, event.messageID);
            } else {
                return api.sendMessage("üö´ Nh√≥m ch∆∞a c√≥ k√≠ hi·ªáu!", event.threadID, event.messageID);
            }
        }

    }
    const delayUnsend = 60;// t√≠nh theo gi√¢y
    if (threadEntry) { 
        if (type === "message_reply") {
            const name = args.join(' ');
            if (name.length > 25) return api.sendMessage(`T√™n nh∆∞ l·ªìn d√†i vcl, ng·∫Øn th√¥i`, threadID)
            const name2 = await Users.getNameUser(messageReply.senderID);

            api.changeNickname(threadEntry.nameUser + ' ' + name, threadID, messageReply.senderID, (err) => {
                if (!err) {
                    api.sendMessage(`‚úÖ ƒê√£ ƒë·ªïi t√™n c·ªßa ${name2} th√†nh ${name || "t√™n g·ªëc"}`, threadID, (error, info) => {
                        if (!error) {
                            setTimeout(() => {
                                api.unsendMessage(info.messageID);
                            }, delayUnsend * 1000);
                        }
                    });
                } else {
                    api.sendMessage(`‚ùé Nh√≥m ch∆∞a t·∫Øt li√™n k·∫øt m·ªùi!!`, threadID);
                }
            });
        } else {
            const mention = Object.keys(mentions)[0];
            const name2 = await Users.getNameUser(mention || senderID);

            if (args.join().indexOf('@') !== -1) {
                const name = args.join(' ').replace(mentions[mention], '');

                api.changeNickname(threadEntry.nameUser + ' ' + name, threadID, mention, (err) => {
                    if (!err) {
                        api.sendMessage(`‚úÖ ƒê√£ ƒë·ªïi t√™n c·ªßa ${name2} th√†nh ${name || "t√™n g·ªëc"}`, threadID, (error, info) => {
                            if (!error) {
                                setTimeout(() => {
                                    api.unsendMessage(info.messageID);
                                }, delayUnsend * 1000);
                            }
                        });
                    } else {
                        api.sendMessage(`‚ùé Nh√≥m ch∆∞a t·∫Øt li√™n k·∫øt m·ªùi!!`, threadID);
                    }
                });
            } else {
                const name = args.join(" ");
                if (name.length > 25) return api.sendMessage(`T√™n nh∆∞ l·ªìn d√†i vcl, ng·∫Øn th√¥i`, threadID)

                api.changeNickname(threadEntry.nameUser + ' ' + name, threadID, senderID, (err) => {
                    if (!err) {
                        api.sendMessage(`‚úÖ ƒê√£ ƒë·ªïi t√™n c·ªßa b·∫°n th√†nh ${name || "t√™n g·ªëc"}`, threadID, (error, info) => {
                            if (!error) {
                                setTimeout(() => {
                                    api.unsendMessage(info.messageID);
                                }, delayUnsend * 1000);
                            }
                        });
                    } else {
                        api.sendMessage(`‚ùé Nh√≥m ch∆∞a t·∫Øt li√™n k·∫øt m·ªùi!!`, threadID);
                    }
                });
            }
        }
    } else {
        if (type === "message_reply") {
            const name = args.join(' ');
            if (name.length > 25) return api.sendMessage(`T√™n nh∆∞ l·ªìn d√†i vcl, ng·∫Øn th√¥i`, threadID)
            const name2 = await Users.getNameUser(messageReply.senderID);

            api.changeNickname(name, threadID, messageReply.senderID, (err) => {
                if (!err) {
                    api.sendMessage(`‚úÖ ƒê√£ ƒë·ªïi t√™n c·ªßa ${name2} th√†nh ${name || "t√™n g·ªëc"}`, threadID, (error, info) => {
                        if (!error) {
                            setTimeout(() => {
                                api.unsendMessage(info.messageID);
                            }, delayUnsend * 1000);
                        }
                    });
                } else {
                    api.sendMessage(`‚ùé Nh√≥m ch∆∞a t·∫Øt li√™n k·∫øt m·ªùi!!`, threadID);
                }
            });
        } else {
            const mention = Object.keys(mentions)[0];
            const name2 = await Users.getNameUser(mention || senderID);

            if (args.join().indexOf('@') !== -1) {
                const name = args.join(' ').replace(mentions[mention], '');

                api.changeNickname(name, threadID, mention, (err) => {
                    if (!err) {
                        api.sendMessage(`‚úÖ ƒê√£ ƒë·ªïi t√™n c·ªßa ${name2} th√†nh ${name || "t√™n g·ªëc"}`, threadID, (error, info) => {
                            if (!error) {
                                setTimeout(() => {
                                    api.unsendMessage(info.messageID);
                                }, delayUnsend * 1000);
                            }
                        });
                    } else {
                        api.sendMessage(`‚ùé Nh√≥m ch∆∞a t·∫Øt li√™n k·∫øt m·ªùi!!`, threadID);
                    }
                });
            } else {
                const name = args.join(" ");
                if (name.length > 25) return api.sendMessage(`T√™n nh∆∞ l·ªìn d√†i vcl, ng·∫Øn th√¥i`, threadID)

                api.changeNickname(name, threadID, senderID, (err) => {
                    if (!err) {
                        api.sendMessage(`‚úÖ ƒê√£ ƒë·ªïi t√™n c·ªßa b·∫°n th√†nh ${name || "t√™n g·ªëc"}`, threadID, (error, info) => {
                            if (!error) {
                                setTimeout(() => {
                                    api.unsendMessage(info.messageID);
                                }, delayUnsend * 1000);
                            }
                        });
                    } else {
                        api.sendMessage(`‚ùé Nh√≥m ch∆∞a t·∫Øt li√™n k·∫øt m·ªùi!!`, threadID);
                    }
                });
            }
        }
    }


}

module.exports.handleReaction = async function ({ api, event, Threads, handleReaction, getText }) {
    if (event.userID != handleReaction.author) return;
    if (Array.isArray(handleReaction.abc) && handleReaction.abc.length > 0) {
        let errorMessage = '';
        let successMessage = `‚úÖ ƒê√£ x√≥a th√†nh c√¥ng ${handleReaction.abc.length} th√†nh vi√™n kh√¥ng set name`;
        let errorOccurred = false;

        for (let i = 0; i < handleReaction.abc.length; i++) {
            const userID = handleReaction.abc[i];
            try {
                await api.removeUserFromGroup(userID, event.threadID);
            } catch (error) {
                errorOccurred = true;
                errorMessage += `‚ö†Ô∏è L·ªói khi x√≥a ${userID} t·ª´ nh√≥m`;
            }
        }
        api.sendMessage(errorOccurred ? errorMessage : successMessage, event.threadID);
    } else {
        api.sendMessage(`Kh√¥ng c√≥ ai!`, event.threadID);
    }
}